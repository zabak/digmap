package pt.utl.ist.lucene.utils.temporal;

import org.apache.log4j.Logger;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;

import pt.utl.ist.lucene.utils.nlp.SentenceSpliter;
import pt.utl.ist.lucene.utils.temporal.tides.TimexesDocument;
import pt.utl.ist.lucene.utils.temporal.tides.Timex2TimeExpression;

/**
 * @author Jorge Machado
 * @date 28/Dez/2009
 * @time 16:54:03
 * @email machadofisher@gmail.com
 */
public class DocumentTemporalSentences {

    private static Logger logger = Logger.getLogger(DocumentTemporalSentences.class);

    String sgml;
    String text;
    List<TemporalSentence> temporalSentences;
    TimexesDocument timexesDocument;

    /**
     * Creates a List of sentences with time expressions
     * @param sgml with \n before each TAG END
     * @param timexesDocument document with timexes generated by ILPS TIMEXTAG using TIDES notation
     * @see "http://fofoca.mitre.org/annotation_guidelines/2005_timex2_standard_v1.1.pdf"
     */
    public DocumentTemporalSentences(String sgml,  TimexesDocument timexesDocument)
    {
        init(sgml,timexesDocument);
    }

    public DocumentTemporalSentences(String sgml,  String timexesXml)
    {
        TimexesDocument timexesDocument = new TimexesDocument(timexesXml);
        init(sgml,timexesDocument);
    }

    public void init(String sgml,  TimexesDocument timexesdocument)
    {
        this.sgml = sgml;
        this.text = sgml.replaceAll("<[^>]+>","");
        temporalSentences = (List<TemporalSentence>) SentenceSpliter.split(text, TemporalSentence.class);
        this.timexesDocument = timexesdocument;


        if(this.timexesDocument != null && this.timexesDocument.getTimex2TimeExpressions() != null && this.timexesDocument.getTimex2TimeExpressions().size()>0)
        {
            Iterator<Timex2TimeExpression> timexExpressionSetIter = this.timexesDocument.getTimex2TimeExpressions().iterator();
            Timex2TimeExpression timex2TimeExpressionsList = timexExpressionSetIter.next();

            if(temporalSentences != null)
            {
                for(TemporalSentence temporalSentence : temporalSentences)
                {
                    while(timex2TimeExpressionsList.getTimeExpressions().size() == 0)
                    {
                        if(timexExpressionSetIter.hasNext())
                            timex2TimeExpressionsList = timexExpressionSetIter.next();
                        else
                        {
                            timex2TimeExpressionsList = null;
                            break;
                        }
                    }
                    if(timex2TimeExpressionsList == null)
                        break;
                    if(timex2TimeExpressionsList.getStartOffset() >= temporalSentence.getEndOffset())
                    {
                        //go to next sentence
                    }
                    else
                    {
                        while(timex2TimeExpressionsList.getStartOffset() >= temporalSentence.getStartOffset() && timex2TimeExpressionsList.getEndOffset() <= temporalSentence.getEndOffset())
                        {
                            temporalSentence.getTimexes().add(timex2TimeExpressionsList);
                            if(timexExpressionSetIter.hasNext())
                                timex2TimeExpressionsList = timexExpressionSetIter.next();
                            else
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }


    public List<Timex2TimeExpression> getTimex2TimeExpressionsSets() {
        return timexesDocument.getTimex2TimeExpressions();
    }

    /**
     *
     * @return found sentences with temporal expressions
     */
    public List<TemporalSentence> getSentences()
    {
        return temporalSentences;
    }


    public List<TimeExpression> getAllNormalizedTimeExpressions()
    {
        if(temporalSentences != null && temporalSentences.size()>0)
        {
            List<TimeExpression> expressions = new ArrayList<TimeExpression>();
            for(TemporalSentence s: temporalSentences)
                expressions.addAll(s.getAllTimeExpressions());
            return expressions;
        }
        else
            logger.error("Document with 0 sentences");
        return null;
    }

    public List<String> getAllNLTimeExpressions()
    {
        if(temporalSentences != null && temporalSentences.size()>0)
        {
            List<String> expressions = new ArrayList<String>();
            for(TemporalSentence s: temporalSentences)
                expressions.addAll(s.getAllNLExpressions());
            return expressions;
        }
        else
            logger.error("Document with 0 sentences");
        return null;
    }



    public String getSgml() {
        return sgml;
    }

    /**
     *
     * @return TEXT without tags
     */
    public String getText() {
        return text;
    }

    public String toString()
    {
        String txt = "REFTIME: " + timexesDocument.getRefTime() +"\n";
        for(TemporalSentence s: getSentences())
        {
            txt += s;
        }
        return txt;
    }
}
